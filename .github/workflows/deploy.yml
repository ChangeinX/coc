name: Build and Deploy

on:
  push:
    branches: [main]

permissions:
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  CLUSTER: ${{ secrets.CLUSTER }}
  APP_REPOSITORY: ${{ secrets.APP_REPOSITORY }}
  WORKER_REPOSITORY: ${{ secrets.WORKER_REPOSITORY }}
  MESSAGES_REPOSITORY: ${{ secrets.MESSAGES_REPOSITORY }}
  USER_REPOSITORY: ${{ secrets.USER_REPOSITORY }}
  NOTIFICATIONS_REPOSITORY: ${{ secrets.NOTIFICATIONS_REPOSITORY }}
  APP_BUCKET: ${{ secrets.APP_BUCKET }}
  PUBLIC_HOME_BUCKET: ${{ secrets.PUBLIC_HOME_BUCKET }}
  APP_DISTRIBUTION_ID: ${{ secrets.APP_DISTRIBUTION_ID }}
  PUBLIC_HOME_DISTRIBUTION_ID: ${{ secrets.PUBLIC_HOME_DISTRIBUTION_ID }}
  AWS_LAMBDA_ARTIFACTS_BUCKET: ${{ secrets.AWS_LAMBDA_ARTIFACTS_BUCKET }}
  LAMBDA_FUNCTION_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME }}
  APP_SERVICE: ${{ secrets.APP_SERVICE }}
  WORKER_SERVICE: ${{ secrets.WORKER_SERVICE }}
  MESSAGES_SERVICE: ${{ secrets.MESSAGES_SERVICE }}
  USER_SERVICE: ${{ secrets.USER_SERVICE }}
  NOTIFICATIONS_SERVICE: ${{ secrets.NOTIFICATIONS_SERVICE }}
  RECRUITING_REPOSITORY: ${{ secrets.RECRUITING_REPOSITORY }}
  RECRUITING_SERVICE: ${{ secrets.RECRUITING_SERVICE }}
  CLASH_DATA_REPOSITORY: ${{ secrets.CLASH_DATA_REPOSITORY }}
  CLASH_DATA_SERVICE: ${{ secrets.CLASH_DATA_SERVICE }}
  VITE_API_URL: ${{ secrets.VITE_API_URL }}
  VITE_GOOGLE_CLIENT_ID: ${{ secrets.VITE_GOOGLE_CLIENT_ID }}
  VITE_VAPID_PUBLIC_KEY: ${{ secrets.VITE_VAPID_PUBLIC_KEY }}

jobs:
  detect:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      public_any_changed: ${{ steps.changes.outputs.public_any_changed }}
      messages_any_changed: ${{ steps.changes.outputs.messages_any_changed }}
      user_any_changed: ${{ steps.changes.outputs.user_any_changed }}
      notifications_any_changed: ${{ steps.changes.outputs.notifications_any_changed }}
      recruiting_any_changed: ${{ steps.changes.outputs.recruiting_any_changed }}
      clash_data_any_changed: ${{ steps.changes.outputs.clash_data_any_changed }}
      lambda_refresh_worker_any_changed: ${{ steps.changes.outputs.lambda_refresh_worker_any_changed }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Detect changes
        id: changes
        uses: tj-actions/changed-files@v46
        env:
          GH_TOKEN: ${{ github.token }}
        with:
          files_yaml: |
            public:
              - front-end/public-home/**
            messages:
              - messages-java/**
              - java-auth-common/**
            user:
              - user_service/**
            notifications:
              - notifications/**
            recruiting:
              - recruiting/**
            clash_data:
              - clash-data/**
            lambda_refresh_worker:
              - lambdas/refresh-worker/**
              - coclib/**


  public-home:
    needs: detect
    if: needs.detect.outputs.public_any_changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Install and build public home
        run: |
          npm ci --prefix front-end/public-home
          npm run --prefix front-end/public-home build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Sync public home to S3
        run: aws s3 sync front-end/public-home/out s3://$PUBLIC_HOME_BUCKET --delete

      - name: Invalidate public home CloudFront cache
        run: |
          aws cloudfront create-invalidation --distribution-id $PUBLIC_HOME_DISTRIBUTION_ID --paths "/*"

  lambda-refresh-worker:
    needs: detect
    if: needs.detect.outputs.lambda_refresh_worker_any_changed == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build Lambda deployment package
        run: |
          cd lambdas/refresh-worker
          chmod +x package-lambda.sh
          ./package-lambda.sh --skip-upload --skip-deploy

      - name: Upload Lambda artifact to S3
        run: |
          ARTIFACT_NAME="refresh-worker-${{ github.sha }}.zip"
          cd lambdas/refresh-worker
          aws s3 cp coc-refresh-worker-lambda.zip s3://$AWS_LAMBDA_ARTIFACTS_BUCKET/$ARTIFACT_NAME
          echo "Lambda artifact uploaded: s3://$AWS_LAMBDA_ARTIFACTS_BUCKET/$ARTIFACT_NAME"

      - name: Deploy Lambda function
        run: |
          ARTIFACT_NAME="refresh-worker-${{ github.sha }}.zip"
          echo "üöÄ Deploying Lambda function..."
          
          # Update Lambda function code
          UPDATE_RESULT=$(aws lambda update-function-code \
            --function-name $LAMBDA_FUNCTION_NAME \
            --s3-bucket $AWS_LAMBDA_ARTIFACTS_BUCKET \
            --s3-key $ARTIFACT_NAME \
            --region $AWS_REGION \
            --output json)
          
          if [[ $? -eq 0 ]]; then
            VERSION=$(echo "$UPDATE_RESULT" | jq -r '.Version')
            LAST_MODIFIED=$(echo "$UPDATE_RESULT" | jq -r '.LastModified')
            
            echo "‚úÖ Lambda function updated successfully"
            echo "üìã Function: $LAMBDA_FUNCTION_NAME"
            echo "üìã Version: $VERSION"
            echo "üìã Last Modified: $LAST_MODIFIED"
            
            # Wait for function to be ready
            echo "‚è≥ Waiting for function to be ready..."
            aws lambda wait function-updated \
              --function-name $LAMBDA_FUNCTION_NAME \
              --region $AWS_REGION
            
            echo "‚úÖ Lambda deployment complete"
          else
            echo "‚ùå Error: Failed to update Lambda function"
            exit 1
          fi

      - name: Upload artifact for OpenTofu deployment
        uses: actions/upload-artifact@v4
        with:
          name: refresh-worker-lambda-${{ github.sha }}
          path: lambdas/refresh-worker/coc-refresh-worker-lambda.zip
          retention-days: 30

  build-push:
    needs: detect
    if: needs.detect.outputs.messages_any_changed == 'true' || needs.detect.outputs.user_any_changed == 'true' || needs.detect.outputs.notifications_any_changed == 'true' || needs.detect.outputs.recruiting_any_changed == 'true' || needs.detect.outputs.clash_data_any_changed == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [messages, user, notifications, recruiting, clash-data]
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 1
          submodules: recursive

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2
        with:
          platforms: linux/arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY

      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ matrix.service }}-${{ hashFiles('**/*.gradle*', '**/gradle.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-${{ matrix.service }}-

      - name: Build & push ${{ matrix.service }} image
        env:
          SERVICE: ${{ matrix.service }}
        run: |
          case "$SERVICE" in
            messages)
              DOCKERFILE=messages-java/Dockerfile
              CONTEXT=.
              REPOSITORY=$MESSAGES_REPOSITORY
              SERVICE_NAME=$MESSAGES_SERVICE
              CHANGED=${{ needs.detect.outputs.messages_any_changed }}
              ;;
            user)
              DOCKERFILE=user_service/Dockerfile
              CONTEXT=user_service
              REPOSITORY=$USER_REPOSITORY
              SERVICE_NAME=$USER_SERVICE
              CHANGED=${{ needs.detect.outputs.user_any_changed }}
              ;;
            notifications)
              DOCKERFILE=notifications/Dockerfile
              CONTEXT=notifications
              REPOSITORY=$NOTIFICATIONS_REPOSITORY
              SERVICE_NAME=$NOTIFICATIONS_SERVICE
              CHANGED=${{ needs.detect.outputs.notifications_any_changed }}
              ;;
            recruiting)
              DOCKERFILE=recruiting/Dockerfile
              CONTEXT=recruiting
              REPOSITORY=$RECRUITING_REPOSITORY
              SERVICE_NAME=$RECRUITING_SERVICE
              CHANGED=${{ needs.detect.outputs.recruiting_any_changed }}
              ;;
            clash-data)
              DOCKERFILE=clash-data/Dockerfile
              CONTEXT=.
              REPOSITORY=$CLASH_DATA_REPOSITORY
              SERVICE_NAME=$CLASH_DATA_SERVICE
              CHANGED=${{ needs.detect.outputs.clash_data_any_changed }}
              ;;
          esac

          if [ "$CHANGED" != "true" ]; then
            echo "No changes in $SERVICE, skipping build."
            exit 0
          fi

          docker buildx build \
            --platform linux/arm64 \
            -f "$DOCKERFILE" \
            --cache-from type=registry,ref=$ECR_REGISTRY/$REPOSITORY:buildcache \
            --cache-to type=registry,ref=$ECR_REGISTRY/$REPOSITORY:buildcache,mode=max \
            -t "$ECR_REGISTRY/$REPOSITORY:latest" \
            -t "$ECR_REGISTRY/$REPOSITORY:${{ github.sha }}" \
            --push "$CONTEXT"

          task_def=$(aws ecs describe-services --cluster $CLUSTER --services $SERVICE_NAME --query 'services[0].taskDefinition' --output text)
          aws ecs describe-task-definition --task-definition "$task_def" --query 'taskDefinition' > taskdef.json
          jq --arg IMAGE "$ECR_REGISTRY/$REPOSITORY:${{ github.sha }}" \
            'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy, .deregisteredAt) | .containerDefinitions[].image=$IMAGE' taskdef.json > new-taskdef.json
          new_def=$(aws ecs register-task-definition --cli-input-json file://new-taskdef.json --query 'taskDefinition.taskDefinitionArn' --output text)
          aws ecs update-service --cluster $CLUSTER --service $SERVICE_NAME --task-definition "$new_def"